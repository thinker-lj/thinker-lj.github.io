---
title: 一次crash引发的持久层重构
date: 2016-09-05 23:15:44
tags: [DataBase, FMDB, 多线程]
categories: [设计实现]
---
![摄于前几日的北戴河之行(与主题有关)](/images/%E5%8C%97%E6%88%B4%E6%B2%B3.jpg)
在北戴河，看到这番层次分明的美景，我脑海里出现了下面要聊的数据库重构…

-------

> 事不过三，三则重构！

-------

# & 背景与痛点
这事儿说来真的话长！很久很久以前，为了保证数据库操作的线程安全，所有操作都放在了主线程，最终，我们这些个小年轻儿忍不了，重构了…
重构最终如火如荼搞完了，但还是年轻，虽然使用了FMDB的内置**串行队列**管理数据库操作，效果也很明显，消息流快的飞起来！但是，偶尔莫名奇妙的crash，给我们泼了一盆冷水…
最终，团队中一个妹子没事儿看代码玩儿，发现了其中的问题，要不说 还是妹子心细啊！其实原因很简单，由于历史遗留问题，外部对数据库的调用，存在多个初始化操作，这样虽然串行队列有了，但是却有多个队列绑定到了多个对象上，所以**crash**是自然的了。
上面说了半天，就是下图描述的问题：
![](/images/14732600573869.jpg)

**因此，我们又走上了重构之路！**<!-- more -->

-------

# & 理想与现实
我们理想中的数据持久层（当然不只是数据库，但这里着重讨论数据库的应用），真不是我们再次重构完成的样子。起初和团队中的旺仔讨论了很久**ORM**，准备撸起袖子大干一场的时候，意识到这样的后果，简直是将之前的Model层、Proxy、数据库接口全部推到重来。最终，我们还是妥协了，对于无法预估的工作量和风险，在工业级产品中是绝对行不通的。我们结合之前的业务，面对现实，搞出了下面这个结构框架：
![](/images/数据库框架图.png)
这里着重提下几个关键路径：
## && 表操作约束协议 - Base Proxy
这个协议主要约束表的相关操作，在表操作的基类中通过一下限制，如果不实现就报异常：

``` objc
- (instancetype)init {
    
    if (self = [super init] && [self conformsToProtocol:@protocol(XXXDatabaseTableAttachment)]) {
        // 获取具体表操作对象
        _child = XXXDatabaseTableProxy <XXXDatabaseTableAttachment> *)self;
        // 子类无需显式调用表创建
        [self createTable];
    }else{
        // 不遵守协议 抛异常
        NSException *exception = [NSException exceptionWithName:@"XXXDatabaseTableProxy init error" reason:@"the child class must conforms to protocol: <XXXDatabaseTableAttachment>" userInfo:nil];
        @throw exception;
    }
    return self;
}
```
同时表的常规操作公共方法都归类到基类的分类中即图中的Proxy Helper。
> 关于Base Proxy的实现，起初考虑的是通过NSProxy利用AOP思想来做消息转发，去支配具体表操作；后来经过细化，发现这样有些过度设计了，不是太好的设计，就放弃了这种方式，进而采用了图中这样，通过很薄的一层Delegate来维系类关系。这部分的具体细节请看我的另一篇着重[探讨NSProxy的文章](http://thinker-lj.com/NSProxy/)。

## && 数据库操作全局调度队列 - Global Queue
考虑到业务层和数据库操作对接部分会造成线程数爆增，在数据库管理类中加入操作数的全局限制队列，根据不同机型和操作系统设置不同默认操作数。这一点在**AFNetworking**和**SDWebImage**的实现中也有所体现。所有操作的入口和出口，都由这个队列进行管理。

-------

# & 几点疑问
下面的内容是对本次重构框架的延伸讨论，其实每个话题都可以独立成篇了。而且存在即合理，但是这里就不说Core Data 和Realm的诸多优点了，下面只做简要的分析和个人观点阐述（纯属一家直言不可轻信）：
## && 1.为什么不考虑Core Data ？
首先**Core Data**并不是ORM！作为一种模型层的技术，持久化并不在它的野心范围，所以这部分直接是SQLite的封装，对象图管理才是的真正目的。具体内容可以参考[这篇文章](https://www.objccn.io/issue-4-1/) 下面是我们起初没有采用这个方案的几点考虑：
* Core Data的类结构复杂 ，学习成本太高；
* 弃用熟悉的**SQL**和正在使用的**FMDB**，无法接受同时也不现实；
* Core Data 性能无优势，而我们的痛点也不在它擅长的那层抽象上面；
* 退一步讲，我们会考虑Realm替代Core Data；

## && 2.为什么不考虑Realm等ORM方案？
[Realm](https://realm.io/cn/)是值得尊敬的！因为它敢宣称永久免费，它敢弃用SQLite重头来搞，它敢和SQLite比性能，它还提供了Core Data到Realm迁移方案……
但是，我们仍然放弃了这个方案！原因有以下几点：
* 我们无法接受它提供的基类，如果恰好继承自**RLMObject**基类的Model又在网络接口中扮演角色，而网络层JSON转Model的框架也提供了基类（情况真实存在），那就很尴尬了；
* Realm 提供的内置数据类型侵入性太强，上了贼船，想下很难；
* 这一点理由很牵强，但是确实影响着我们：相比几十岁的SQLite，Realm太年轻……

## && 3.如何制定数据库迁移方案？
需求变更和业务演进，都会导致数据库结构的变化；想不丢失原有的本地数据，就要考虑数据库的迁移方案。
如果你使用的是**FMDB**，那庆幸的的是**FMDBMigrationManager**专门做这件事；Core Data等也有类似的迁移方案，由于项目中还暂时没有遇到此类问题，等真正实践过会独立成篇。

-------

# & 最后
套用Realm的广告，更好的持久层设计，意味着更好的移动端应用。持久层的确关系重大，这也正如标题所言，一次Crash都足以引起我们的重视，同时对它的任何修改，我们也保持保守审慎的态度。因此，最终本次持久层重构并没有如当初预想的大刀阔斧推倒重来，而是在操作队列和协议约束几个关键点上做了调整；这样既没有动太多原有具体表操作的Proxy，减小了影响范围，也达到了解决现有问题的目的。



