---
title: Swift 之闭包与循环引用
date: 2016-03-23 19:54:12
tags: [闭包, 循环引用]
categories: Swift
---
> 危险的不是技术本身，而是使用它的人过于笨拙…

-------

# & 引子
接触Swift以后，闭包引起了我的注意，我本人是从C语言开始接触编程的，后续玩了汇编等更低级的语言。个人感觉，从底层这样一步步往上层走，会有种时刻被惊艳到的欣喜。还记得第一次闭包这个特性惊艳到我，是在上学时把玩**Python**，当然这门语言里，这种特性叫**lambda**，后来为了把妹，在**JavaScript**中又做了深入学习，当然**Objective-C**的**block**，也在匿名函数的讨论范畴。所以，现在走进Swift的世界，对闭包感到十分亲切，同时感到也有必要更加深入的理解闭包。不过，同样保持一贯作风，本文不是闭包语法级的科普文，有这个需求的请Google或者去看官方文档。

-------

# & 闭包共识
Swift中一般的闭包表达式语法就为如下形式：
```swift
{ (parameters) -> returnType in
    statements
}
```
这里不多说，有一点需要注意，跟其他语言对匿名函数的定义不太一样的地方，关键词**in**的意义：表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。
在讨论循环引用之前，需要提前针对几个细节达成共识：
* 闭包是引用类型
它和函数一样，无论是在常量还是变量之间赋值，你得到的都是闭包的引用。对于这点理解，与Objective-C中的block被当做对象来实现，有些差异。当有一点它们是相同的：都是引用类型。
* 变量捕获
闭包是可以捕获变量的，如果被捕获的变量是引用类型，闭包也势必会持有指向它们的强引用。为了捕获变量，这当然是必要的，这也就引出了下面要讨论的循环引用，这一点可以类比block。

不难看出Swift中的闭包的关键理解都可以类比block，虽然二者有着本质的不同。<!-- more -->

-------

# & 循环引用
看下面这个例子：

```swift
class Manager {
    let name:String
    var foo:() -> String = {
    	guard let name = self.name else {
    		return ""
    	}
    }
    init(name:String) {
    	self.name = name
    }
    deinit {
    	println("Manager deinit")
    }
}
```
循环引用是由foo函数造成的，foo变量被类Manager所持有，而它持有了一个闭包的引用，闭包内部的实现，引用了Manger。这很显然，造成了循环引用。可能用图来说明，更加清晰：![](/images/14858829211060.jpg)


下面我们试着打破这个循环引用：
* 将foo的引用变为weak？这样显然不合理，很有可能会因为没有指向它的强引用而消失。
* 将闭包标记为weak？这样也不行，闭包是无法被标记为weak的。即便可以，这样也是不合理的，会对后续手动赋值带来影响。
* 通过使用**捕获列表**，避免闭包对Manger的引用。这才是正确的的方式。

## && 捕获列表
针对上面的循环应用，我们可以通过使用捕获列表并将捕获变量self标记为**weak**或者**unowned**。在本例中，Manager的生命周期肯定会长于foo变量，所以使用unowned更为合理。如果使用了weak，self将会是一个可选值，那调用起来就成了self？；下面是修改过的代码：

```swift
class Manager {
        … …
	var test:() -> String = {
		[unowned self] in
		guard let name = self.name else {
			return ""
		}
	}
	… …
}
```
这和上面闭包的定义几乎是一样的，只有在捕获列表的地方有所不同。通过维护Manager的一个unowned引用，从而打破了上面的循环引用。

-------

# &  最后
对于Swift中闭包的理解，抓住上面提到的两个核心概念：引用类型和变量捕获。这样就可以类比在其他语言中的类似特性，至于细节也就更容易掌握了。


