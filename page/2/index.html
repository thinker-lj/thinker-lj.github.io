<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="一个很会写代码的伪文艺青年">
<meta property="og:type" content="website">
<meta property="og:title" content="暖壶盖儿">
<meta property="og:url" content="http:&#x2F;&#x2F;thinker-lj.github.io&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="暖壶盖儿">
<meta property="og:description" content="一个很会写代码的伪文艺青年">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://thinker-lj.github.io/page/2/"/>


  <title> 暖壶盖儿 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-89139845-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?733c7768164bf371bb204c415d266f30";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">暖壶盖儿</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSDWebImage/" itemprop="url">
                  源码解析之SDWebImage
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-26T15:02:53+08:00" content="2016-05-26">
              2016-05-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码解析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSDWebImage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="源码解析之SDWebImage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>Asynchronous image downloader with cache support as a UIImageView category</p>
</blockquote>
<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>“一个支持缓存的异步下载图片的UIImageView分类”,这是SDWebImage官方的相当保守的自我描述；<br>看完下图，就可以了解作者有多么的谦虚；<br>下图我旨在表现SDWebImage的清晰的模块划分和任务分级策略，并不能全面的涵盖它的一切。<br><img src="/images/14695977227412.jpg" alt="SDWebImage 模块划分与任务分级"></p>
<p>从标题就可以知晓，如果你只是想了解SDWebImage的用法，那最好直接去看<a href="https://github.com/rs/SDWebImage/blob/master/README.md" target="_blank" rel="noopener">README.md</a>;<br>下面我会按照任务分级和模块划分，从以下几个方面抽丝剥茧：</p>
<hr>
<h1 id="amp-Cache-缓存管理"><a href="#amp-Cache-缓存管理" class="headerlink" title="&amp; Cache -缓存管理"></a>&amp; Cache -缓存管理</h1><p>内存缓存和磁盘都由<strong>SDImageCache</strong>处理，即有关图片缓存的一切，都封装在这个类里了；</p>
<h2 id="amp-amp-一-整体流程"><a href="#amp-amp-一-整体流程" class="headerlink" title="&amp;&amp; 一 整体流程"></a>&amp;&amp; 一 整体流程</h2><ul>
<li>缓存命中流程：<ol>
<li>通过外部传入的key，首先检查是否命中内存缓存，命中则直接返回；</li>
<li>检查是否命中磁盘缓存，未命中则返回；</li>
<li>命中磁盘缓存，检查是否开启内存缓存，开启则设置内存缓存，并返回命中结果；</li>
</ol>
</li>
</ul>
<h2 id="amp-amp-二-内存缓存"><a href="#amp-amp-二-内存缓存" class="headerlink" title="&amp;&amp; 二 内存缓存"></a>&amp;&amp; 二 内存缓存</h2><p>先来说内存缓存，就像<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFN</a>作者所说，<a href="http://nshipster.cn/nscache/" target="_blank" rel="noopener">NSCache</a>就可以处理一切你想要的了；SDImageCache内部的<strong>memCache</strong>是一个<strong>NSCache</strong>对象，因此直接通过<strong>- setObject:forKey:</strong>就可以设置缓存，但是作者使用了<strong>- setObject:forKey:cost:</strong>，用意是通过<strong>const</strong>来向系统传递单一缓存大小，从而通过系统对整个缓存大小的控制，有效控制整个缓存的容量。但是，这就是NSCache最坑的地方，你永远也无法知道，当缓存到达你设置的临界时，到底是哪部分缓存被清除了（清除也有可能不是立即进行的）。瑕不掩瑜吧，看来作者也并没因此放弃对NSCache的使用。另外，提到const，作者提供了一个计算图片大小的方法，很精简，直接贴出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE <span class="built_in">NSUInteger</span> SDCacheCostForImage(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">    <span class="keyword">return</span> image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其实这个方法计算出来的并不是图片所占字节数，而是像素点，SDWebImage官方也在<a href="https://github.com/rs/SDWebImage/issues/1369" target="_blank" rel="noopener">此处</a>进行了说明；所以，如果要计算图片所占的大小，可以这样做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延续作者的思路</span></span><br><span class="line">image.size.height * image.size.width * image.scale * image.scale * <span class="built_in">CGImageGetBitsPerPixel</span>(image.CGImage) / CHAR_BIT</span><br><span class="line"><span class="comment">// 更简洁的方式</span></span><br><span class="line"><span class="built_in">CGImageGetBytesPerRow</span>(image.CGImage) * <span class="built_in">CGImageGetHeight</span>(image.CGImage)</span><br></pre></td></tr></table></figure>
<p>以上都是题外话，因为这个计算方法只用在了内存缓存，上面也提到了NSCache的坑，所以此处，这个值也就无所谓了。<br>另外，关于内存缓存删除的触发，除了NSCache的自动处理外（这部分毕竟是不可控的），作者还监听了<strong>UIApplicationDidReceiveMemoryWarningNotification</strong>做了更加保险的处理。</p>
<h2 id="amp-amp-三-磁盘缓存"><a href="#amp-amp-三-磁盘缓存" class="headerlink" title="&amp;&amp; 三  磁盘缓存"></a>&amp;&amp; 三  磁盘缓存</h2><p>较之内存缓存成熟的NSCache方案，磁盘缓存要相对复杂一些了；<br>因为作者旨在实现的是一个图片缓存管理，相对来说，图片属于大容量对象存储。因此，这里作者直接使用文件存储这种方式，而不是像其他缓存策略那样，数据库和文件并用，也是合理的。</p>
<ol>
<li><p>存储<br> 存储部分，剖去外层一系列的判断，最终会调用下面的方法：  </p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!imageData) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get cache Path for image key</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// transform to NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">// disable iCloud backup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 贴出这个方法，是为了说明，作者并没有在每次的磁盘缓存中去做缓存容量和时间的判断，而是很粗暴的进行了文件存储。<br> 为什么会这么做？所有对磁盘缓存的操作，都放在了<strong>ioQueue</strong>这个串行队列中，试想，如果每次存储都做缓存时效和空间大小的判断和处理，那这个存储效率就太低了，同时缓存的维护代价会变得非常大。当然，外部设置的缓存时效和空间限制也并不是形同虚设，稍后会在缓存清理中做解释。</p>
</li>
<li><p>缓存清理<br>先解释上面的问题，缓存清理会在应用进入后台和应用即将被终止时进行。<br>因为作者监听了<strong>UIApplicationDidEnterBackgroundNotification</strong> 和 <strong>UIApplicationWillTerminateNotification</strong>这两个通知。<br>这两个通知，最终都会调用<strong>cleanDiskWithCompletionBlock</strong>方法，这个方法是整个缓存管理类营养价值最高的地方。由于代码量过大，这里就不贴出来了。下面提几个关键点：</p>
<ul>
<li>缓存清除策略:时间维度(优先考虑过期时间)和空间维度(LRU逐步衰减)；</li>
<li>清理工作不会立即进行，考虑I/O阻塞和数组遍历修改易crash等因素，待清除对象最后统一处理。</li>
<li>采用LRU,而非LFU的原因：文件缓存天然具有修改时间监控优势，这种实现方式维护成本更低。</li>
</ul>
</li>
</ol>
          <div class="post-more-link text-center">
            <a class="btn" href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSDWebImage/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/NSURLProtocol/" itemprop="url">
                  你真的会用NSURLProtocol？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-01T15:22:55+08:00" content="2016-05-01">
              2016-05-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/NSURLProtocol/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="NSURLProtocol/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="/images/NSURLProtocol_p0.jpeg" alt="题图来自最近玩的一个小游戏"></p>
<hr>
<blockquote>
<p>NSURLProtocol 或许是URL加载系统中功能最强大但同时也是最晦涩的部分了…</p>
<p align="right">—— [Mattt Thompson](http://nshipster.cn/authors/mattt-thompson/)</p>                                                
</blockquote>
<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>网上针对NSURLProtocol的讨论不仅少之又少，而且在仅有的资料中还有不少纰漏。显然大多停留在文档阅读或者demo阶段，并没有在工业级项目中应用。这也是我写这篇文章的原因，还是一贯原则：实践出真知！所以本文主要探讨笔者在项目中对NSURLProtocol的应用，旨在填坑和思维发散…</p>
<hr>
<h2 id="amp-amp-谈几点经验："><a href="#amp-amp-谈几点经验：" class="headerlink" title="&amp;&amp; 谈几点经验："></a>&amp;&amp; 谈几点经验：</h2><ul>
<li>NSURLProtocol处在iOS开发中的核武器级别，一旦<strong>registerClass</strong>，影响的是整个项目的URL加载系统；</li>
<li>鉴于上条原因谈到的影响范围，在工业级项目中使用时记得周知QA，做好全面回归覆盖case；</li>
<li>处理好<strong>request</strong>标记，防止死循环；</li>
<li>尽可能全部处理<strong>NSURLProtocolClient</strong>，尤其是<strong>重定向</strong>的方法；</li>
<li>复杂业务场景下，谨慎处理多个NSURLProtocol子类的注册和继承嵌套；</li>
<li>可处理<strong>NSURLConnection</strong>、<strong>NSURLSession</strong>、<strong>UIWebView</strong> 对<strong>WKWebView</strong>无法截获；</li>
</ul>
<blockquote>
<p>上面谈到NSURLProtocol功能强大，接下来只聊已经实践过的几个case，希望可以抛砖引玉…</p>
</blockquote>
          <div class="post-more-link text-center">
            <a class="btn" href="/NSURLProtocol/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BAFNetworking/" itemprop="url">
                  源码解析之AFNetworking
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-15T23:47:51+08:00" content="2016-04-15">
              2016-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">源码解析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BAFNetworking/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="源码解析之AFNetworking/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X.<br>It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
</blockquote>
<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>毫无疑问，AFNetworking是个宝藏！用过它的人很多，但是如果你不满足于只是成为这个开源库的使用者，那就一起探索下它到底有多精彩！<br>开始之前有几点说明：</p>
<ul>
<li>AFNetworking在我写这篇文章时已经更新到3.x，最新版对URLConnection进行了阉割。个人认为这部分的细节依然干货满满，所以，下面的分析没有针对某个版本，着重在关键的几个重要实现。</li>
<li>本文假设阅读之前你已对 <strong>HTTP(s)</strong> 、<strong>多线程编程</strong>、<strong>URL加载系统</strong>有足够的了解。如果仍然云里雾里，停下来去了解下基础吧，文中也会在恰当处提供些较权威链接。</li>
<li>源码面前，了无秘密！没关注到的点，请阅读源码，同时也欢迎批评指正。</li>
</ul>
<p>阅读源码，有个习惯，总会先梳理出框架的整体结构。这里从一个网络请求被AFNetworking接手到处理完成的角度，给出一个囊括主要功能类的结构图。当然，被3.x阉割的部分，也标注在它该有的位置。<br><img src="/images/14744435828503.jpg" alt=""><br>整体来说，框架分为三层，请求被接手后首先是些编码序列化等处理。然后交给发送请求的管理类，这里也是最精彩核心的部分。最后，对返回结果再次进行格式化处理，至此AFNetworking任务完成。<br>下面，具体聊下每部分动辄上千行代码都做了什么…</p>
<hr>
<h1 id="amp-OperationManager"><a href="#amp-OperationManager" class="headerlink" title="&amp; OperationManager"></a>&amp; OperationManager</h1><p>先从最核心的请求调度部分说起，无论是底层是采用 <strong>NSURLConnection</strong> 还是 <strong>NSURLSession</strong> ，每个请求都被封装成一个继承自 <strong>NSOperation</strong> 的对象，而OperationManager自然就是对多个请求的管理类。但具体到NSURLConnection和NSURLSession的实现上，又略有不同，下面具体说明：</p>
<h2 id="amp-amp-URLConnection"><a href="#amp-amp-URLConnection" class="headerlink" title="&amp;&amp; URLConnection"></a>&amp;&amp; URLConnection</h2><p>再次强调，虽然 <strong>NSURLConnection</strong> 已经退出历史舞台并且AFNetworking的3.x版本已经剔除由NSURLConnection发的请求的封装类，但是，这里仍然会把它和NSURLSession同等看待。况且，二者的处理不仅存在差异，而且同样精巧！</p>
<h3 id="amp-amp-amp-AFURLConnectionOpration"><a href="#amp-amp-amp-AFURLConnectionOpration" class="headerlink" title="&amp;&amp;&amp; AFURLConnectionOpration"></a>&amp;&amp;&amp; AFURLConnectionOpration</h3><p>先讨论一个关键问题：众所周知，NSURLConnection相关线程处理的异步网络请求，开始和回调需要在同一个线程，否则 <strong>delegate</strong> 无法被触发。这就涉及到如何做<strong>线程保活</strong>，等待回调触达。AFNetworking是这样做的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式首先出现在 <strong>WWDC</strong> 中，因此这里也只是借鉴，不是首创！<br>此 <strong>Runloop</strong> 与下面的全局网络请求线程做了绑定，所以NSURLConnection的网络请求，都是从这个线程发出并做回调处理的，最终做了默认回到主线程处理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图描述了整个NSURLConnection请求的关键技术，AFURLConnectionOpration解决的主要难题。请求由不同的线程并发的发出，包装成operation，交付给上面提到的全局保活线程串行处理，然后NSURLConnection相关线程做真正的网络请求处理，将回调抛回全局线程，全局线程将处理的结果，继续抛回请求发出的线程。<br><img src="/images/14744436276195.jpg" alt=""><br>关键问题说明白了，下面提几个关注到的技术点：</p>
<ul>
<li>Operation状态机<br>  为了保证NSOperation在加入到NSOperationQueue后的有效性，状态的控制通过 <strong>KVO</strong> 处理。继承自NSOperation的AFURLConnectionOpration针对操作的各个状态进行了统一管理，内部的状态统一由 <strong>AFOperationState</strong> 枚举类型属性state处理。处理的过程主要涉及到对状态转换的限制，枚举和NSOperation状态的一一对应等细节。</li>
<li>递归锁<br>  用锁的原因是为了保证能访问到成员变量的对外接口在多线程环境下的线程安全。锁的实现方式有很多种，这里之所以要采用NSRecursiveLock递归锁，是为了在内部无法确认请求的执行环境时，防止造成死锁的异常容错处理方式。
          <div class="post-more-link text-center">
            <a class="btn" href="/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BAFNetworking/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/Swift%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" itemprop="url">
                  Swift 之闭包与循环引用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-23T19:54:12+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/Swift%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="Swift之闭包与循环引用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>危险的不是技术本身，而是使用它的人过于笨拙…</p>
</blockquote>
<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>接触Swift以后，闭包引起了我的注意，我本人是从C语言开始接触编程的，后续玩了汇编等更低级的语言。个人感觉，从底层这样一步步往上层走，会有种时刻被惊艳到的欣喜。还记得第一次闭包这个特性惊艳到我，是在上学时把玩<strong>Python</strong>，当然这门语言里，这种特性叫<strong>lambda</strong>，后来为了把妹，在<strong>JavaScript</strong>中又做了深入学习，当然<strong>Objective-C</strong>的<strong>block</strong>，也在匿名函数的讨论范畴。所以，现在走进Swift的世界，对闭包感到十分亲切，同时感到也有必要更加深入的理解闭包。不过，同样保持一贯作风，本文不是闭包语法级的科普文，有这个需求的请Google或者去看官方文档。</p>
<hr>
<h1 id="amp-闭包共识"><a href="#amp-闭包共识" class="headerlink" title="&amp; 闭包共识"></a>&amp; 闭包共识</h1><p>Swift中一般的闭包表达式语法就为如下形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不多说，有一点需要注意，跟其他语言对匿名函数的定义不太一样的地方，关键词<strong>in</strong>的意义：表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。<br>在讨论循环引用之前，需要提前针对几个细节达成共识：</p>
<ul>
<li>闭包是引用类型<br>它和函数一样，无论是在常量还是变量之间赋值，你得到的都是闭包的引用。对于这点理解，与Objective-C中的block被当做对象来实现，有些差异。当有一点它们是相同的：都是引用类型。</li>
<li>变量捕获<br>闭包是可以捕获变量的，如果被捕获的变量是引用类型，闭包也势必会持有指向它们的强引用。为了捕获变量，这当然是必要的，这也就引出了下面要讨论的循环引用，这一点可以类比block。</li>
</ul>
<p>不难看出Swift中的闭包的关键理解都可以类比block，虽然二者有着本质的不同。
          <div class="post-more-link text-center">
            <a class="btn" href="/Swift%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/Leaks/" itemprop="url">
                  内存泄漏这件大事儿
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-26T22:20:19+08:00" content="2016-02-26">
              2016-02-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/" itemprop="url" rel="index">
                    <span itemprop="name">技术实践</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/Leaks/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="Leaks/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>你骄傲的和别人说，嘿，我写了个能让Windows崩溃的程序，他们会说“哥们儿，我装Windows系统的时候就免费带着了”</p>
<p align="right">—— Linus Benedict Torvalds</p>
</blockquote>
<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>自打“小时候”接触C语言时，对内存处理机制的探究和兴趣，使我最终爱上了写代码这件事，最终走向了这条“不归路”……<br>本文当然不是内存基础知识科普，出于这个目的进来的朋友，我想Google更适合你！<br>今天主要聊聊iOS平台日常开发实践中，笔者经常遇到的内存泄露问题及处理策略。</p>
<hr>
<h1 id="amp-平台相关"><a href="#amp-平台相关" class="headerlink" title="&amp; 平台相关"></a>&amp; 平台相关</h1><p>众所周知，早在5.0时iOS平台引入了自动引用计数(ARC)技术，这固然解放了不少在内存管理上面耗费的精力，可我始终认为，便捷和效率的提升带来的负面影响就是更多的人只为赶路，开始忽略背后的技术实现。这样的结局就是出了问题后的束手无策！<br>有了ARC，并不代表我们已经轻松到不需要了解内存管理的相关技术，恰恰相反，这是在MRC的基础上，又多了一种需要掌握的技术；同时也不能代表从此我们不会遇到内存相关的问题，实际上这要是本文探讨的核心问题。</p>
<hr>
<h1 id="amp-值类型和引用类型"><a href="#amp-值类型和引用类型" class="headerlink" title="&amp; 值类型和引用类型"></a>&amp; 值类型和引用类型</h1><p>内存中需要管理的对象大致也就这两类：值类型和引用类型。值类型，例如int、枚举、结构体等基本数据类型(Swift 中集合类型也被实现为值语义，这带来诸多好处)都紧密排列位于栈中(这点并不绝对，例如较大结构体有置于堆中的可能)，这部分由系统统一管理，不在我们内存泄露的讨论范围。引用类型，也即是跟类扯上关系的一切实例，分配的内存在堆上面，需要我们手动管理，这部分体现在Foundation框架层就交由ARC来管理，当然通过桥接Core Foundation也可以借助ARC管理内存。我们所说的内存泄露，也主要是在引用类型的讨论上。
          <div class="post-more-link text-center">
            <a class="btn" href="/Leaks/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/git-flow/" itemprop="url">
                  用更加优雅的方式做事：Git Flow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-11T15:33:50+08:00" content="2016-02-11">
              2016-02-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%B8%B8/" itemprop="url" rel="index">
                    <span itemprop="name">项目日常</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/git-flow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="git-flow/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="/images/gitflow_p0.jpg" alt=""></p>
<blockquote>
<p>软件就像性，免费的比花钱的好得多…</p>
</blockquote>
<p align="right">—— 李纳斯·托沃兹</p>

<hr>
<h1 id="amp-引子"><a href="#amp-引子" class="headerlink" title="&amp; 引子"></a>&amp; 引子</h1><p>网络时代，随便找个地方，不等Git三个字母敲完，资料就出来了。所以，这篇只聊个人观点，项目实战后的感悟。不喜，随意喷！对朋友，我骂人比谁都脏……</p>
<hr>
<h1 id="amp-从SVN谈起："><a href="#amp-从SVN谈起：" class="headerlink" title="&amp; 从SVN谈起："></a>&amp; 从SVN谈起：</h1><p>提到版本控制系统，首先要聊两句更纯粹些的SVN，之所以说它纯粹，是因为这种集中式的数据仓库更符合常规思维，它只提供一种途径，这样每个人都使用着相同的方式。<br>而Git却不仅仅是个版本控制系统，大家更愿意把它理解成一个强大的文件系统；虽然不能完全说Git可以取代SVN（实际上它正在做这件事），因为SVN仍然有它的使用场景（例如项目中存在部分无法公开的内容）。<br>但Git 的分布式管理方式更加便捷，分支管理更加轻松，内容更具完整性；这也是我们团队最终从SVN 迁移到Git主要原因。</p>
<hr>
<h1 id="amp-Git-Flow"><a href="#amp-Git-Flow" class="headerlink" title="&amp; Git Flow"></a>&amp; Git Flow</h1><blockquote>
<p>便利的工具在没有规范约束时，往往会成为双刃剑……</p>
</blockquote>
<p>​    在开聊Git Flow前，下面这张图可以看到模型的全貌（引自nvie的<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">博文</a>)：</p>
<p><img src="/images/gitflow_p1.png" alt=""></p>
<p>​    图一放，顿时不想聊太多了……</p>
<hr>
<h1 id="amp-讲故事"><a href="#amp-讲故事" class="headerlink" title="&amp; 讲故事"></a>&amp; 讲故事</h1><p>​    Git Flow让我想起了当年的铁道游击队骑着自行车追火车的场景，先把正义感抛开，不管目的是军需还是兵力补充，小范围来看火车都是 <strong>master branch</strong> 了。所以在火车跑起来之前，安全策略就要提前规划好。不要让游击队这种小的 <strong>develop branch</strong> 随意的merge！Github Flow的 <strong>Pull request</strong> 也好，Gitlab flow的 <strong>Merge request</strong>也罢，无非就是为了保证上了火车的人都是经过 <strong>code review</strong> 的。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/git-flow/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
      
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/%E5%BC%80%E7%AF%87/" itemprop="url">
                  写在前面
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-02T15:01:19+08:00" content="2016-02-02">
              2016-02-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E5%9F%8E%E5%B0%8F%E4%BA%8B/" itemprop="url" rel="index">
                    <span itemprop="name">大城小事</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/%E5%BC%80%E7%AF%87/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="开篇/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p> <img src="/images/1432602686559636.jpg" alt="图片来源于池建强老师"></p>
<p>在很多地方写过博客……</p>
<p>接触coding开始，每个阶段都留下些东西；</p>
<p>最终又回到了这里，出发时的地方；</p>
<p>之前的就留在那里吧，不做迁移了！从这里重新出发……</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/%E5%BC%80%E7%AF%87/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/logo.png"
               alt="thinker-lj" />
          <p class="site-author-name" itemprop="name">thinker-lj</p>
          <p class="site-description motion-element" itemprop="description">一个很会写代码的伪文艺青年</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">thinker-lj</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"thinker-lj"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  






  
  

  

  

  

  


</body>
</html>
