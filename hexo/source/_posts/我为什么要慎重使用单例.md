---
title: 为什么要慎重使用单例
date: 2016-09-25 21:58:05
tags: [单例, 设计模式]
categories: [设计实现]
---

![家在武夷山附近的同事家的蓝天(与主题有关)](/images/IMG_0499.jpg)
家在武夷山附近的基友说，这是他们家的蓝天…

-------

> 达到某种目的有很多种方式，但会不会目的本身就是错的？

-------

# & 引子
**手里拿着锤子，看什么都像钉子！**我想每个在coding同时持续learning的人都会经历过这种走火入魔的状态。多人合作开发时，总会需要模块间传值桥接，这时为图方便时常会听到一句话：算了吧，粗暴点，我给你搞个单例吧！需求愉快的做完了，但坑也就此埋下了…
自从**GCD**引入以后，单例一般都这么来写了：

```objc
+ (instancetype)sharedInstance
{
    static id sharedInstance;
    // Xcode 居然给 "Dispatch Once" 搞了个默认代码片段
    static dispatch_once_t once;
    dispatch_once(&once, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}
```

实现简单，并非意味着可以肆无忌惮。单例纵使有千般好，今天全不提，我们下面讨论滥用的危害。

-------

# & 病态的单例
## && 全局状态的问题
单例不仅唯一而且是**全局状态**，显然太多的全局状态，是程序设计首先要规避的问题。

### &&& 场景一
考虑下面这个场景：假如我把图片下载管理类设计成单例，现在有两个入口，入口A需要对图片进行某种规格的压缩，而入口B需要另外一种不同于A的压缩。如果两个入口在App的一个生命周期内都被触发过，那后者的设置就把前者**覆盖**掉了，换句话说，因为这种全局状态同一时间只会使一种配置生效。显然这种全局状态不仅没必要而且会造成难以调试的奇怪**bug**。
<!-- more --> 
### &&& 场景二
上面的场景是后者覆盖前者产生了问题，可有时候后者无法覆盖前者，问题更严重啊！
下面再聊一个更常见也更惊悚的场景：
任何App都逃不开用户相关信息的管理，它们大多也都逃不开使用单例来做这件事。用户信息当然也具有全局性，但它绝非唯一。考虑这样一种普遍情况，**多账户登录**。如下图所描述的情形，谁都不想让下一个登录的用户看到上一个登录用户的信息吧，更可怕也更常见的是**信息错乱**。我们的工程中也犯了这个错误，用一个单例保存了用户基本资料和地理位置信息等，这在单一用户登录状态下，运转一切良好。项目推进下，接入多用户登录，上面的坑也就出现了。
![多用户状态切换](/images/14755589048996.jpg)
为了避免出现多用户信息错乱，加入了通知等状态监控，在状态切换中对单例重置。现在虽然依然可以保证一切正常，但是**重置单例**这种策略，就不再符合我们初衷了……
## && 代理不该出现
其实这种情况，也应归属于全局状态引发的问题。但是，它又足够特殊，所以单拿出来着重强调下。
下图已经把这种情形描述的很清楚，和上面提到的图片下载两个入口配置不同的道理类似，只是这里特殊一些。所以，任何时候都**不要再单例中夹杂代理模式**！因为无法预知单例被怎样使用，它的指向随时都可能被改写。
![单例代理错误](/images/14755566489417.jpg)
## && 讨厌继承又多了一个理由
项目中，我很少使用自实现基类的继承写法！因为碰到的继承能解决的问题，都用分类搞定了。
但是，也许是受其他编程语言的影响，总有人习惯使用继承，理由也都很简单，分类能搞定的，用继承也一样嘛！
考虑下面这个情形，有很多个类，有一个共同特点：都是单例！为避免重复性工作，喜欢继承的朋友，可能会搞个单例基类，然后让这些类继承它。但是，你用子类调用基类的单例构造方法，得到的仍然是**基类对象**，而不是你想要的**子类对象**。这个道理很好理解，但是因为对某种技术的**偏执**，很容易让人盲目，而在简单问题上犯错误！还是那句话，把技术放在它应呆的地方！

-------

# & 如果重来
上面谈了单例错用的几种常见情形，为了给大家留足思考空间，没在上面的问题中谈太多个人想法。这里简单聊下：
* 类似下载管理的场景，错不在使用单例，而是处理的颗粒大小。在真正的**核心**下载部分，使用单例没有错，但是外围的设置，需要有入口和出口的配合，这里就不适合囊括在单例里面。处理这种全局状态的被错乱覆盖的问题，请确保，你的单例**只做好一件事**，其他交付给**外围**或者**上层调用**去处理。
* 场景二提到的用户信息管理类问题，不用单例，又该怎么搞？
可以借鉴的策略是[依赖注入](https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)配合**数据持久化**！所有依赖用户信息的类，在构造时都将用户信息对象作为参数传入，这样既降低了耦合，也再用户状态切换时，及时更新了用户信息。
* 单例中出现代理的问题，这里不必多谈了，请用通知去搞定，复杂情形，通知也可以锁定接收对象的。
* 上面提到的单例基类问题，这里我想用分类试试：

``` objc
@interface NSObject (SharedInstance)

+ (instancetype)sharedInstance;

@end

@implementation NSObject (SharedInstance)

+ (instancetype)sharedInstance
{
    Class selfClass = [self class];
    id instance = objc_getAssociatedObject(selfClass, @"SharedInstance");
    if (!instance) {
    
        instance = [[selfClass alloc] init];
        objc_setAssociatedObject(selfClass, @"SharedInstance", instance, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
    return instance;
}

@end
```

-------

# & 正确姿势
**对象的生命周期和App的生命周期一样，可以考虑使用单例，其他情况请避开！**
举个栗子：**AFNetworking**有个网络监控的类，它用单例来做就再好不过了。同样的，定位管理、下载管理等都可以考虑使用单例。对于**可以考虑**的情况，也要规避前面讨论的情况…

-------

# & 最后
本篇文章算是给单例发了张好人卡！它虽然实现简单，易于理解使用，但是必须在适合它的地方应用。我们不能犯拿着锤子看什么都是钉子的盲目错误。

-------
参考文献：
[Avoiding Singleton Abuse](https://www.objc.io/issues/13-architecture/singletons/)


